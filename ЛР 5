(define (def-arifm-oper oper)
  (cond
    ((equal? oper '+) '+)
    ((equal? oper '-) '-)
    ((equal? oper '*) '*)
    ((equal? oper '/) '/)))

(define (comp-oper? oper)
  (or
   (equal? oper '<)
   (equal? oper '=)
   (equal? oper '>)))

(define (make-log-oper oper stack)
  (cond
    ((and (equal? oper '<)(< (cadr stack) (car stack))) -1)
    ((and (equal? oper '>)(> (cadr stack) (car stack))) -1)
    ((and (equal? oper '=)(= (cadr stack) (car stack))) -1)
    (else 0)))

(define (replace n stack)
  (set! stack (cons n (cddr stack)))
  stack)

(define ie (interaction-environment))

(define (skeeper-count vect i)
  (if (equal? (vector-ref vect i) 'end)
      i
      (skeeper-count vect (+ i 1))))

(define (skeeper-count-if vect i)
  (if (equal? (vector-ref vect i) 'endif)
      i
      (skeeper-count-if vect (+ i 1))))
        

(define (interpret program stack)
  (define (helper i _stack returns_stack defs)
    (if (= i (vector-length program))
        _stack
        (let ((word (vector-ref program i))) 
          (cond
            ((number? word) (helper (+ i 1) (cons word _stack) returns_stack defs))
            ((equal? word (def-arifm-oper word))(helper (+ i 1)
                                                        (replace (eval(list word (cadr _stack) (car _stack))ie) _stack) returns_stack defs))
            ((equal? word 'neg) (helper (+ i 1) (cons (-(car _stack)) (cdr _stack)) returns_stack defs))
            ((equal? word 'mod) (helper (+ i 1) (replace (remainder (cadr _stack) (car _stack)) _stack)returns_stack defs))
            ((comp-oper? word) (helper (+ i 1) (replace (make-log-oper word _stack) _stack) returns_stack defs))
            ((equal? word 'not) (helper (+ i 1) (cons (if (= (car _stack) 0) -1 0) (cdr _stack)) returns_stack defs))
            ((equal? word 'and) (helper (+ i 1) (cons (if (and (= (car _stack) 0) (= (cadr _stack) 0)) -1 0) (cddr _stack)) returns_stack defs))
            ((equal? word 'or) (helper (+ i 1) (cons (if (or (= (car _stack) 0) (= (cadr _stack) 0)) -1 0) (cddr _stack)) returns_stack defs))
            ((equal? word 'drop) (helper (+ i 1) (cdr _stack) returns_stack defs))
            ((equal? word 'swap) (helper (+ i 1) (append (cons (cadr _stack) (list (car _stack))) (cddr _stack)) returns_stack defs))
            ((equal? word 'dup) (helper (+ i 1) (cons (car _stack) _stack) returns_stack defs))
            ((equal? word 'over) (helper (+ i 1) (cons (cadr _stack) _stack)returns_stack defs))
            ((equal? word 'rot) (helper (+ i 1) (append (list (caddr _stack) (cadr _stack) (car _stack)) (cdddr _stack)) returns_stack defs))
            ((equal? word 'depth) (length _stack))
            ((equal? word 'define) (helper (+ (skeeper-count program i) 1) _stack returns_stack
                                           (cons (list (vector-ref program (+ i 1)) (+ i 2)) defs)))
            ((or(equal? word 'end) (equal? word 'exit)) (helper (car returns_stack) _stack (cdr returns_stack) defs))
            ((equal? word 'if) (helper (if (equal? (car _stack) 0)(+ (skeeper-count-if program i) 1) (+ i 1)) (cdr _stack) returns_stack defs))
            ((equal? word 'endif) (helper (car returns_stack) _stack returns_stack defs))
            (else (helper (cadr (assoc word defs)) _stack (cons (+ i 1) returns_stack) defs))))))
          
          
  (helper 0 stack '() '()))
                                                 





(interpret #(2 3 * 4 5 * +) '())
(interpret #(   define -- 1 - end
                5 -- --      ) '())
(interpret #(   define abs 
                    dup 0 < 
                    if neg endif 
                end 
                 9 abs 
                -9 abs      ) (quote ()))
(interpret #(   define =0? dup 0 = end 
                define <0? dup 0 < end 
                define signum 
                    =0? if exit endif 
                    <0? if drop -1 exit endif 
                    drop 
                    1 
                end 
                 0 signum 
                -5 signum 
                10 signum       ) (quote ()))
(interpret #(   define -- 1 - end 
                define =0? dup 0 = end 
                define =1? dup 1 = end 
                define factorial 
                    =0? if drop 1 exit endif 
                    =1? if drop 1 exit endif 
                    dup -- 
                    factorial 
                    * 
                end 
                0 factorial 
                1 factorial 
                2 factorial 
                3 factorial 
                4 factorial     ) (quote ()))
(interpret #(   define =0? dup 0 = end 
                define =1? dup 1 = end 
                define -- 1 - end 
                define fib 
                    =0? if drop 0 exit endif 
                    =1? if drop 1 exit endif 
                    -- dup 
                    -- fib 
                    swap fib 
                    + 
                end 
                define make-fib 
                    dup 0 < if drop exit endif 
                    dup fib 
                    swap -- 
                    make-fib 
                end 
                10 make-fib     ) (quote ()))
(interpret #(   define =0? dup 0 = end 
                define gcd 
                    =0? if drop exit endif 
                    swap over mod 
                    gcd 
                end 
                90 99 gcd 
                234 8100 gcd    ) '())
